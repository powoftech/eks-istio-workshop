var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Mô tả workshop Workshop AWS toàn diện này sẽ dạy bạn cách xây dựng, bảo mật và giám sát các ứng dụng container hóa bằng các công nghệ cloud-native hiện đại và thực tiễn DevSecOps. Bạn sẽ tạo ra một pipeline container bảo mật hoàn chỉnh từ đầu đến cuối bao gồm quét lỗ hổng, thực thi chính sách và phát hiện mối đe dọa runtime.\nTrong suốt workshop thực hành này, bạn sẽ:\nXây dựng pipeline CI/CD bảo mật sử dụng GitHub Actions để tự động build, quét và triển khai các ứng dụng container hóa Triển khai quét lỗ hổng container với các tính năng bảo mật tích hợp của Amazon ECR Triển khai thực thi chính sách sử dụng Kyverno như một admission controller của Kubernetes để ngăn chặn các workload không an toàn Thiết lập phát hiện mối đe dọa runtime với Falco để giám sát và cảnh báo về hành vi đáng ngờ của container Cung cấp và quản lý các cluster Amazon EKS với các thực tiễn bảo mật tốt nhất Áp dụng các nguyên tắc DevSecOps bằng cách tích hợp bảo mật vào mọi giai đoạn của vòng đời phát triển Khi kết thúc workshop này, bạn sẽ có một pipeline triển khai container sẵn sàng cho production, ưu tiên bảo mật, tự động ngăn chặn các image có lỗ hổng đến production và phát hiện mối đe dọa trong thời gian thực.\nĐối tượng mục tiêu Workshop này được thiết kế cho:\nKỹ sư DevOps muốn triển khai các kiểm soát bảo mật trong pipeline container của họ Kỹ sư Bảo mật muốn học các công cụ và thực tiễn bảo mật cloud-native Kỹ sư Platform xây dựng các nền tảng Kubernetes bảo mật cho các nhóm phát triển Nhà phát triển Phần mềm quan tâm đến việc hiểu bảo mật container và thực tiễn triển khai bảo mật Kiến trúc sư Cloud thiết kế các giải pháp container hóa bảo mật trên AWS Kỹ sư Độ tin cậy Site (SRE) triển khai giám sát bảo mật và thực thi chính sách Kiến thức giả định Người tham gia nên có:\nKinh nghiệm container hóa cơ bản với Docker (build image, chạy container) Kiến thức Kubernetes cơ bản (pod, deployment, service, namespace) Hiểu biết cơ bản về AWS (quen thuộc cơ bản với các dịch vụ và khái niệm AWS) Thành thạo dòng lệnh trong môi trường Linux/Unix Kinh nghiệm Git và GitHub cho version control và khái niệm CI/CD cơ bản Quen thuộc với cú pháp YAML cho Kubernetes manifest và file cấu hình Kinh nghiệm trước đây với EKS, công cụ bảo mật hoặc policy engine sẽ hữu ích nhưng không bắt buộc vì workshop cung cấp hướng dẫn từng bước.\nThời gian hoàn thành workshop Tổng thời gian: 3-4 giờ\nPhân chia module:\nThiết lập và Điều kiện tiên quyết: 30 phút Tạo Repository Dự án: 20 phút Ứng dụng và CI Workflow: 45 phút Cung cấp EKS Cluster: 30 phút Thiết lập Kyverno Policy Engine: 45 phút Bảo mật Runtime Falco: 30 phút Kiểm tra và Xác thực: 30 phút Dọn dẹp: 15 phút Workshop được thiết kế để hoàn thành trong một phiên làm việc, với các điểm nghỉ tự nhiên sau mỗi module chính. Tất cả việc cung cấp cơ sở hạ tầng và triển khai đều được bao gồm trong ước tính thời gian.",
    "description": "Mô tả workshop Workshop AWS toàn diện này sẽ dạy bạn cách xây dựng, bảo mật và giám sát các ứng dụng container hóa bằng các công nghệ cloud-native hiện đại và thực tiễn DevSecOps. Bạn sẽ tạo ra một pipeline container bảo mật hoàn chỉnh từ đầu đến cuối bao gồm quét lỗ hổng, thực thi chính sách và phát hiện mối đe dọa runtime.\nTrong suốt workshop thực hành này, bạn sẽ:",
    "tags": [],
    "title": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "uri": "/vi/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "Chào mừng bạn đến với workshop AWS toàn diện này, nơi bạn sẽ học cách xây dựng, bảo mật và giám sát các ứng dụng container hóa sử dụng các công nghệ cloud-native hiện đại. Workshop thực hành này sẽ hướng dẫn bạn tạo một pipeline DevSecOps hoàn chỉnh cho các ứng dụng Kubernetes.\nAmazon Elastic Container Registry (ECR) Amazon Elastic Container Registry (ECR) là một registry Docker container được quản lý hoàn toàn, giúp các nhà phát triển dễ dàng lưu trữ, quản lý và triển khai các Docker container image. ECR được tích hợp với Amazon EKS và Amazon ECS, đơn giản hóa quy trình từ phát triển đến sản xuất.\nTính năng chính:\nQuản lý hoàn toàn: Không cần quản lý hoặc bảo trì hạ tầng Bảo mật: Các image được mã hóa khi lưu trữ và truyền tải, với tính năng quét lỗ hổng bảo mật Tính khả dụng cao: Được xây dựng trên Amazon S3 với độ bền 99.999999999% (11 số 9) Tích hợp: Hoạt động liền mạch với các dịch vụ AWS và IAM để kiểm soát truy cập chi tiết Hiệu quả chi phí: Chỉ trả tiền cho dung lượng lưu trữ bạn sử dụng mà không có phí trả trước Trong workshop này, bạn sẽ sử dụng ECR để lưu trữ các image ứng dụng container hóa và tích hợp với pipeline CI/CD.\nAmazon Elastic Kubernetes Service (EKS) Amazon Elastic Kubernetes Service (EKS) là một dịch vụ Kubernetes được quản lý hoàn toàn, giúp bạn dễ dàng chạy Kubernetes trên AWS mà không cần cài đặt, vận hành và bảo trì control plane hoặc node Kubernetes của riêng mình.\nLợi ích chính:\nControl Plane được quản lý hoàn toàn: AWS quản lý control plane Kubernetes, bao gồm tính khả dụng cao và các bản vá bảo mật Bảo mật theo mặc định: Tích hợp với AWS IAM, VPC và security groups Tính khả dụng cao: Control plane chạy trên nhiều Availability Zone Tương thích Kubernetes: Cập nhật thường xuyên để hỗ trợ các phiên bản Kubernetes mới nhất Tích hợp: Hoạt động với các dịch vụ AWS như ECR, ALB, EBS, EFS và CloudWatch Trong workshop này, bạn sẽ cung cấp một EKS cluster để triển khai và quản lý các ứng dụng container hóa với khả năng bảo mật và giám sát nâng cao.\nGitHub Actions GitHub Actions là một nền tảng CI/CD mạnh mẽ cho phép bạn tự động hóa các quy trình phát triển phần mềm trực tiếp từ repository GitHub của mình. Nó cho phép bạn build, test và deploy code ngay từ GitHub.\nKhả năng chính:\nTự động hóa quy trình: Tự động hóa các quy trình build, test và deployment Điều khiển bằng sự kiện: Kích hoạt workflow dựa trên các sự kiện GitHub như push, pull request hoặc release Marketplace: Truy cập hàng nghìn action được xây dựng sẵn từ cộng đồng Matrix Builds: Test trên nhiều hệ điều hành và phiên bản cùng lúc Quản lý Secrets: Lưu trữ và sử dụng thông tin nhạy cảm một cách an toàn trong workflow Trong workshop này, bạn sẽ tạo các GitHub Actions workflow để tự động build, scan và deploy ứng dụng lên EKS.\nKyverno Policy Engine Kyverno là một policy engine được thiết kế cho Kubernetes, cho phép bạn quản lý các cluster policy dưới dạng code. Nó cung cấp cách tiếp cận declarative để quản lý policy mà không cần học ngôn ngữ mới.\nTính năng chính:\nPolicy dựa trên YAML: Viết policy sử dụng cú pháp YAML quen thuộc của Kubernetes Validation: Thực thi các quy tắc cho cấu hình resource Mutation: Tự động sửa đổi resource để tuân thủ các tiêu chuẩn Generation: Tạo thêm resource dựa trên các quy tắc policy Reporting: Tạo báo cáo vi phạm policy Trong workshop này, bạn sẽ sử dụng Kyverno như một cluster gatekeeper để thực thi các policy bảo mật và quy tắc quản trị.\nFalco Runtime Security Falco là một công cụ bảo mật runtime mã nguồn mở phát hiện hành vi ứng dụng bất thường và cảnh báo về các mối đe dọa trong thời gian thực. Nó hoạt động như một camera an ninh cho các Kubernetes cluster của bạn.\nKhả năng bảo mật:\nPhát hiện mối đe dọa Runtime: Giám sát các kernel call và phát hiện hoạt động đáng ngờ Hiểu biết về Kubernetes: Hiểu được context và resource của Kubernetes Quy tắc linh hoạt: Định nghĩa quy tắc tùy chỉnh cho yêu cầu bảo mật cụ thể Đầu ra đa dạng: Gửi cảnh báo đến nhiều đích khác nhau (Slack, PagerDuty, v.v.) Cloud-Native: Được thiết kế đặc biệt cho môi trường container hóa Trong workshop này, bạn sẽ triển khai Falco để giám sát ứng dụng và phát hiện các mối đe dọa bảo mật tiềm ẩn trong thời gian thực.",
    "description": "Chào mừng bạn đến với workshop AWS toàn diện này, nơi bạn sẽ học cách xây dựng, bảo mật và giám sát các ứng dụng container hóa sử dụng các công nghệ cloud-native hiện đại. Workshop thực hành này sẽ hướng dẫn bạn tạo một pipeline DevSecOps hoàn chỉnh cho các ứng dụng Kubernetes.\nAmazon Elastic Container Registry (ECR) Amazon Elastic Container Registry (ECR) là một registry Docker container được quản lý hoàn toàn, giúp các nhà phát triển dễ dàng lưu trữ, quản lý và triển khai các Docker container image. ECR được tích hợp với Amazon EKS và Amazon ECS, đơn giản hóa quy trình từ phát triển đến sản xuất.",
    "tags": [],
    "title": "Giới thiệu",
    "uri": "/vi/introduction/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "Trước khi bắt đầu workshop này, bạn cần cài đặt và cấu hình một số công cụ thiết yếu giúp bạn tương tác với các dịch vụ AWS và các cluster Kubernetes. Những công cụ này tạo nền tảng để làm việc với container và tài nguyên AWS, đặc biệt là Amazon EKS.\nAWS CLI AWS Command Line Interface (CLI) là một công cụ thống nhất cho phép bạn quản lý các dịch vụ AWS từ terminal. Bạn sẽ sử dụng nó để cấu hình thông tin xác thực AWS, tạo và quản lý tài nguyên AWS, và tương tác với các dịch vụ AWS khác nhau trong suốt workshop này.\nCài đặt: Tải xuống và cài đặt AWS CLI từ tài liệu chính thức của AWS.\nCấu hình: Sau khi cài đặt, chạy aws configure để thiết lập access key, region mặc định và định dạng đầu ra.\nkubectl kubectl là công cụ dòng lệnh của Kubernetes cho phép bạn chạy các lệnh với cluster Kubernetes. Bạn sẽ sử dụng nó để triển khai ứng dụng, kiểm tra và quản lý tài nguyên cluster, và xem log trong cluster EKS của mình.\nCài đặt: Làm theo tài liệu Kubernetes để cài đặt kubectl cho hệ điều hành của bạn.\nXác minh: Chạy kubectl version --client để xác minh việc cài đặt.\neksctl eksctl là một công cụ dòng lệnh để tạo và quản lý cluster Kubernetes trên Amazon EKS. Nó đơn giản hóa quá trình tạo cluster EKS và worker node, tự động xử lý phần lớn việc thiết lập hạ tầng AWS bên dưới.\nCài đặt: Tải xuống eksctl từ GitHub releases chính thức hoặc sử dụng trình quản lý gói của bạn.\nXác minh: Chạy eksctl version để xác nhận việc cài đặt.\nHelm Helm là trình quản lý gói cho Kubernetes giúp bạn quản lý các ứng dụng Kubernetes. Bạn sẽ sử dụng Helm để cài đặt và cấu hình Kyverno, Falco và các ứng dụng khác trên cluster EKS của mình bằng cách sử dụng các chart đã được cấu hình sẵn.\nCài đặt: Cài đặt Helm theo tài liệu Helm chính thức.\nXác minh: Chạy helm version để xác minh việc cài đặt.\nDocker Docker là một nền tảng container hóa cho phép bạn xây dựng, đóng gói và chạy ứng dụng trong container. Bạn sẽ sử dụng Docker để xây dựng container image cho ứng dụng của mình và hiểu cách các workload được container hóa hoạt động trong môi trường Kubernetes.\nCài đặt: Tải xuống và cài đặt Docker Desktop từ trang web Docker chính thức hoặc sử dụng trình quản lý gói của hệ thống cho Docker Engine.\nXác minh: Chạy docker --version để xác nhận việc cài đặt và docker run hello-world để kiểm tra rằng Docker có thể pull và chạy container.\nLưu ý: Đảm bảo tất cả các công cụ đã được thêm vào PATH của hệ thống và có thể truy cập từ terminal trước khi tiếp tục.",
    "description": "Trước khi bắt đầu workshop này, bạn cần cài đặt và cấu hình một số công cụ thiết yếu giúp bạn tương tác với các dịch vụ AWS và các cluster Kubernetes. Những công cụ này tạo nền tảng để làm việc với container và tài nguyên AWS, đặc biệt là Amazon EKS.\nAWS CLI AWS Command Line Interface (CLI) là một công cụ thống nhất cho phép bạn quản lý các dịch vụ AWS từ terminal. Bạn sẽ sử dụng nó để cấu hình thông tin xác thực AWS, tạo và quản lý tài nguyên AWS, và tương tác với các dịch vụ AWS khác nhau trong suốt workshop này.",
    "tags": [],
    "title": "Yêu cầu tiên quyết",
    "uri": "/vi/prerequisites/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "Mọi dự án tốt đều cần một nơi lưu trữ.\nTruy cập GitHub (hoặc nhà cung cấp Git ưa thích của bạn).\nTạo một repository public mới. Đặt tên nó như secure-container-pipeline.\nClone repository về máy local của bạn:\ngit clone \u003cyour-repository-url\u003e cd secure-container-pipeline",
    "description": "Mọi dự án tốt đều cần một nơi lưu trữ.\nTruy cập GitHub (hoặc nhà cung cấp Git ưa thích của bạn).\nTạo một repository public mới. Đặt tên nó như secure-container-pipeline.\nClone repository về máy local của bạn:\ngit clone \u003cyour-repository-url\u003e cd secure-container-pipeline",
    "tags": [],
    "title": "Tạo Repository Dự án",
    "uri": "/vi/create-project-repository/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "Tạo Ứng dụng Mẫu và Dockerfile Trước tiên, chúng ta cần một thứ gì đó để build. Chúng ta sẽ tạo một ứng dụng Node.js “Hello World” rất đơn giản và một Dockerfile có ý thức bảo mật.\nTrong thư mục dự án secure-container-pipeline của bạn, tạo một thư mục mới có tên app.\nmkdir app cd app Tạo file ứng dụng Node.js app.js:\n# Trong thư mục 'app' touch app.js Dán đoạn code server đơn giản này vào app/app.js:\n// app/app.js const http = require(\"http\"); const port = 8080; const server = http.createServer((req, res) =\u003e { res.statusCode = 200; res.setHeader(\"Content-Type\", \"text/plain\"); res.end(\"Hello, FCJ-ers!\\n\"); }); server.listen(port, () =\u003e { console.log(`Server running on port ${port}`); }); Tạo Dockerfile:\n# app/Dockerfile # Stage 1: Sử dụng base image cụ thể, slim để giảm bề mặt tấn công. FROM node:22-slim AS base # Tạo một user và group chuyên dụng, không phải root cho ứng dụng. # Đây là một biện pháp bảo mật quan trọng. RUN addgroup --system --gid 1001 nodejs RUN adduser --system --uid 1001 appuser WORKDIR /home/appuser/app # Chỉ copy file cần thiết và đặt quyền chính xác. COPY --chown=appuser:nodejs app.js . # Chuyển sang user không phải root. Mọi lệnh tiếp theo chạy với user này. USER appuser # Expose port mà app chạy. EXPOSE 8080 # Lệnh để chạy ứng dụng. CMD [ \"node\", \"app.js\" ] Quay lại root directory của dự án:\ncd .. Tạo ECR Repository Hãy tạo container registry bảo mật nơi chúng ta sẽ lưu trữ các Docker image.\nChạy lệnh AWS CLI này trong terminal của bạn:\naws ecr create-repository \\ --repository-name workshop-app \\ --image-scanning-configuration scanOnPush=true \\ --region us-east-2 # Sử dụng cùng region với cluster của bạn Thông tin Flag --image-scanning-configuration scanOnPush=true là kiểm soát bảo mật có chủ ý đầu tiên của chúng ta. Chúng ta đã hướng dẫn AWS tự động quét mọi image mới mà chúng ta push vào repository này để tìm các lỗ hổng đã biết (CVE). Đây là một phần nền tảng của pipeline bảo mật của chúng ta.\nThiết lập Quyền truy cập Bảo mật từ GitHub Actions đến AWS (OIDC) Chúng ta cần cấp quyền cho GitHub để push image vào ECR repository của chúng ta. Chúng ta sẽ sử dụng phương pháp hiện đại, bảo mật, không cần mật khẩu: OIDC (OpenID Connect).\nTrong AWS Console, đi đến IAM → Identity providers. Click Add provider. Chọn OpenID Connect. Với Provider URL, nhập https://token.actions.githubusercontent.com. Với Audience, nhập sts.amazonaws.com. Click Add provider. Tạo IAM Role cho GitHub Actions. Đi đến IAM → Roles → Create role. Với Trusted entity type, chọn Web identity. Từ dropdown Identity provider, chọn provider token.actions.githubusercontent.com mà bạn vừa tạo. Với Audience, chọn sts.amazonaws.com. Với GitHub organization/repository, nhập thông tin chi tiết của bạn. Với dự án cá nhân, bạn có thể cụ thể: Organization: your-github-username Repository: secure-container-pipeline (Tùy chọn nhưng khuyến nghị) Branch: main hoặc master Click Next. Trên màn hình Add permissions, tìm và attach policy AmazonEC2ContainerRegistryPowerUser. Điều này cung cấp đủ quyền để đăng nhập và push image vào ECR. Click Next. Đặt tên cho role, như WorkshopGitHubActionsRole (Nhớ tên role. Bạn sẽ sử dụng role này để deploy vào EKS cluster sau) Tạo role. QUAN TRỌNG: Click vào role mới mà bạn vừa tạo và copy ARN của nó. Nó sẽ giống như arn:aws:iam::\u003c\u003cAWS Account ID\u003e\u003e:role/WorkshopGitHubActionsRole. Bạn sẽ cần điều này cho bước tiếp theo. Tạo GitHub Actions CI Workflow Đây là trung tâm của quá trình build và scan tự động của chúng ta.\nTạo cấu trúc thư mục workflow:\nmkdir -p .github/workflows Tạo file workflow ci.yml:\ntouch .github/workflows/ci.yml Dán YAML sau vào .github/workflows/ci.yml. Thay thế placeholder bằng Role ARN thực tế của bạn.\n# .github/workflows/ci.yml name: CI Workflow for EKS Workshop # Workflow này chạy trên mọi push vào branch main on: push: branches: [main] # Cho phép bạn chạy workflow này thủ công từ tab Actions workflow_dispatch: env: AWS_REGION: us-east-2 # AWS region của bạn ECR_REPOSITORY: workshop-app # Tên ECR repository của bạn EKS_CLUSTER_NAME: workshop-cluster # Tên EKS cluster của bạn jobs: build-scan-push: name: Build, Scan \u0026 Push runs-on: ubuntu-latest outputs: image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.image-def.outputs.tag }} permissions: # Bắt buộc cho kết nối OIDC đến AWS id-token: write contents: read steps: - name: Checkout repository uses: actions/checkout@v5 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: arn:aws:iam::\u003c\u003cAWS Account ID\u003e\u003e:role/WorkshopGitHubActionsRole # \u003c-- DÁN ROLE ARN CỦA BẠN VÀO ĐÂY aws-region: ${{ env.AWS_REGION }} - name: Login to Amazon ECR id: login-ecr uses: aws-actions/amazon-ecr-login@v2 - name: Define image tag id: image-def run: echo \"tag=${{ github.sha }}\" \u003e\u003e $GITHUB_OUTPUT - name: Build, tag, and push image to Amazon ECR id: build-image env: ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }} IMAGE_TAG: ${{ steps.image-def.outputs.tag }} run: | docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f app/Dockerfile ./app docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG - name: Security Scan with Trivy uses: aquasecurity/trivy-action@master with: image-ref: \"${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.image-def.outputs.tag }}\" format: \"table\" # Fail build nếu Trivy tìm thấy bất kỳ lỗ hổng nào với mức độ nghiêm trọng HIGH hoặc CRITICAL exit-code: \"1\" ignore-unfixed: true vuln-type: \"os,library\" severity: \"CRITICAL,HIGH\" Commit và push để kích hoạt workflow\nThêm tất cả file mới vào Git, commit chúng và push:\ngit add . git commit -m \"feat: Add sample app, Dockerfile, and initial CI workflow\" git push origin main Quan sát phép màu! Đi đến GitHub repository của bạn, click vào tab Actions. Bạn sẽ thấy workflow của mình đang chạy. Click vào nó để xem log cho từng bước. Nó sẽ:\nCheck out code. Kết nối an toàn đến AWS. Đăng nhập vào ECR. Build và push Docker image của bạn. Quan trọng, sau đó nó sẽ chạy Trivy để quét image mà bạn vừa push.",
    "description": "Tạo Ứng dụng Mẫu và Dockerfile Trước tiên, chúng ta cần một thứ gì đó để build. Chúng ta sẽ tạo một ứng dụng Node.js “Hello World” rất đơn giản và một Dockerfile có ý thức bảo mật.\nTrong thư mục dự án secure-container-pipeline của bạn, tạo một thư mục mới có tên app.\nmkdir app cd app Tạo file ứng dụng Node.js app.js:\n# Trong thư mục 'app' touch app.js Dán đoạn code server đơn giản này vào app/app.js:",
    "tags": [],
    "title": "Tạo Ứng dụng Có thể Build Bảo mật và CI Workflow",
    "uri": "/vi/create-secure-buildable-application-and-ci-workflow/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "Tạo Cấu hình EKS Cluster Chúng ta sẽ sử dụng eksctl để build cluster. Thực tiễn tốt nhất là định nghĩa cluster trong một file cấu hình, sau đó bạn có thể commit vào Git repository để kiểm soát phiên bản và tái tạo.\nTrong root directory của dự án, tạo thư mục mới có tên k8s.\nmkdir k8s cd k8s Tạo file mới có tên cluster.yaml\nDán nội dung sau vào cluster.yaml. Đọc các comment để hiểu từng dòng làm gì\n# k8s/cluster.yaml apiVersion: eksctl.io/v1alpha5 kind: ClusterConfig metadata: # Tên cluster của bạn name: workshop-cluster # AWS region nơi cluster sẽ được tạo region: us-east-2 # Phiên bản Kubernetes của cluster version: \"1.33\" # Section này định nghĩa các Kubernetes worker node nodeGroups: - name: ng-1-workers # Tên cho node group instanceType: t3.medium # Instance type general-purpose mặc định. desiredCapacity: 2 # Bắt đầu với 2 node cho high availability minSize: 1 # Để tiết kiệm chi phí, bạn có thể scale down xuống 1 node khi không test tích cực maxSize: 3 # Giới hạn max size để ngăn chi phí vượt quá do tai nạn # Khuyến nghị: Sử dụng AWS Bottlerocket OS để bảo mật tốt hơn và footprint nhỏ hơn amiFamily: Bottlerocket # Khuyến nghị: Launch nodegroup trong private subnet privateNetworking: true accessConfig: authenticationMode: API_AND_CONFIG_MAP # Tạo EKS access entry để giúp GitHub Actions workflow có thể deploy vào cluster accessEntries: # QUAN TRỌNG: Thay thế \u003c\u003cAWS Account ID\u003e\u003e bằng AWS Account ID của bạn - principalARN: arn:aws:iam::\u003c\u003cAWS Account ID\u003e\u003e:role/WorkshopGitHubActionsRole accessPolicies: - policyARN: arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy accessScope: type: cluster Khởi chạy EKS Cluster Bây giờ, thực thi lệnh để build cluster.\nMở terminal trong thư mục secure-container-pipeline.\nChạy lệnh tạo:\neksctl create cluster -f k8s/cluster.yaml Hãy kiên nhẫn. Quá trình này sẽ mất 15-20 phút. eksctl sẽ in ra rất nhiều thông tin khi nó cung cấp các tài nguyên trong AWS CloudFormation. Hãy đi uống cà phê.\nXác nhận: Khi hoàn tất, eksctl sẽ tự động cập nhật file kubeconfig local của bạn (~/.kube/config). Điều này có nghĩa kubectl bây giờ sẽ trỏ đến EKS cluster mới của bạn.\nXác minh Quyền truy cập Cluster Hãy đảm bảo bạn có thể giao tiếp với cluster mới.\nChạy lệnh kubectl này:\nkubectl get nodes Bạn sẽ thấy output liệt kê hai worker node, tương tự như thế này:\nNAME STATUS ROLES AGE VERSION ip-192-168-158-45.us-east-2.compute.internal Ready \u003cnone\u003e 6m16s v1.33.1-eks-b9364f6 ip-192-168-173-179.us-east-2.compute.internal Ready \u003cnone\u003e 6m21s v1.33.1-eks-b9364f6 Tạo Kubernetes Deployment Manifest Chúng ta cần nói với Kubernetes cách chạy ứng dụng của chúng ta. Chúng ta sẽ làm điều này với hai file tài nguyên Kubernetes tiêu chuẩn: một Deployment (để quản lý các Pod ứng dụng) và một Service (để expose ứng dụng ra traffic).\nTrong root directory của dự án, tạo thư mục mới có tên k8s.\nmkdir k8s cd k8s Tạo file deployment.yaml:\n# Trong thư mục 'k8s' touch deployment.yaml Dán nội dung này vào k8s/deployment.yaml. Chú ý đặc biệt đến dòng ##IMAGE_TAG_PLACEHOLDER##; chúng ta sẽ thay thế điều này một cách động trong pipeline của chúng ta.\n# k8s/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: workshop-app labels: app: workshop-app spec: replicas: 2 # Chạy hai instance cho availability selector: matchLabels: app: workshop-app template: metadata: labels: app: workshop-app spec: containers: - name: workshop-app # QUAN TRỌNG: Đây là placeholder. Pipeline của chúng ta sẽ thay thế nó. image: \"IMAGE_PLACEHOLDER\" ports: - containerPort: 8080 # --- Security Context --- # Điều này thực thi các thực tiễn bảo mật tốt nhất ở cấp độ container. securityContext: # Ngăn container có được nhiều quyền hơn parent process. allowPrivilegeEscalation: false # Chạy container với read-only root filesystem. readOnlyRootFilesystem: true # Củng cố non-root user của Dockerfile. runAsNonRoot: true # Chỉ định user và group ID để chạy, khớp với Dockerfile. runAsUser: 1001 runAsGroup: 1001 # Drop tất cả Linux capability và chỉ thêm lại những gì cần thiết (không có trong trường hợp này). capabilities: drop: - \"ALL\" # Vị trí cho file tạm thời, vì root filesystem là read-only. volumes: - name: tmp emptyDir: {} Tạo file service.yaml:\n# Trong thư mục 'k8s' touch service.yaml Dán nội dung này vào k8s/service.yaml. Điều này sẽ tạo một service LoadBalancer, tự động cung cấp AWS Network Load Balancer để expose ứng dụng của bạn ra internet.\n# k8s/service.yaml apiVersion: v1 kind: Service metadata: name: workshop-app-service spec: selector: app: workshop-app # Type này tạo external AWS Load Balancer type: LoadBalancer ports: - protocol: TCP port: 80 # Port mà load balancer lắng nghe targetPort: 8080 # Port mà container lắng nghe Quay lại root directory của dự án:\ncd .. Cập nhật IAM Role cho Quyền Deployment WorkshopGitHubActionsRole của chúng ta có thể push vào ECR, nhưng nó chưa thể giao tiếp với EKS cluster. Chúng ta cần cấp quyền cho nó.\nTrong AWS Console, đi đến IAM → Roles →.\nChọn role WorkshopGitHubActionsRole.\nTrong tab Permissions, section Permissions policies, chọn Add permissions → Create inline policy.\nVới Policy editor, chọn JSON, dán policy sau và thay thế AWS account ID:\n{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"Statement1\", \"Effect\": \"Allow\", \"Action\": \"eks:DescribeCluster\", \"Resource\": \"arn:aws:eks:us-east-2:\u003c\u003cAWS Account ID\u003e\u003e:cluster/workshop-cluster\" } ] } Click Next.\nĐặt tên cho policy, như DescribeWorkshopEKSCluster.\nTạo policy.\nCập nhật GitHub Actions Workflow để Deploy Bây giờ, chúng ta sẽ thêm job deploy mới vào file ci.yml.\nMở .github/workflows/ci.yml.\nThêm job deploy mới vào cuối file. File hoàn chỉnh, cập nhật sẽ giống như thế này:\n# .github/workflows/ci.yml # ... (các tham số khác được bỏ qua) ... jobs: build-scan-push: # ... (job build-scan-push vẫn giữ nguyên như trước) ... # ---- JOB DEPLOY MỚI ---- deploy: # Job này chỉ chạy nếu job 'build-scan-push' thành công name: Deploy to EKS needs: build-scan-push runs-on: ubuntu-latest permissions: # Bắt buộc cho kết nối OIDC đến AWS id-token: write contents: read steps: - name: Checkout repository uses: actions/checkout@v5 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v4 with: role-to-assume: arn:aws:iam::\u003c\u003cAWS Account ID\u003e\u003e:role/WorkshopGitHubActionsRole # \u003c-- DÁN ROLE ARN CỦA BẠN VÀO ĐÂY aws-region: ${{ env.AWS_REGION }} - name: Set up Kubeconfig for EKS run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} - name: Substitute image tag in Kubernetes manifest run: | sed -i 's|IMAGE_PLACEHOLDER|${{ needs.build-scan-push.outputs.image }}|' k8s/deployment.yaml - name: Deploy to EKS cluster run: | echo \"--- Applying deployment.yaml ---\" cat k8s/deployment.yaml kubectl apply -f k8s/deployment.yaml echo \"--- Applying service.yaml ---\" kubectl apply -f k8s/service.yaml Thay đổi Chính:\nJob deploy mới được thêm vào. needs: build-scan-push đảm bảo deployment chỉ xảy ra sau khi build và scan thành công. Lệnh sed là bước quan trọng tìm IMAGE_PLACEHOLDER và thay thế nó bằng image URI thực tế, unique từ bước build. kubectl apply gửi cấu hình của chúng ta đến EKS cluster. Commit, push và xác minh deployment:\nCommit thay đổi của bạn:\ngit add . git commit -m \"feat: Add k8s manifests and deploy job to CI workflow\" git push origin main Theo dõi pipeline: Đi đến tab Actions trong GitHub. Bạn sẽ thấy pipeline đầy đủ chạy. Lần này, sau khi “Build, Scan \u0026 Push” hoàn tất, job “Deploy to EKS” sẽ bắt đầu.\nXác minh trong terminal: Khi pipeline thành công, kiểm tra trạng thái deployment của bạn.\nKiểm tra pod:\nkubectl get pods -l app=workshop-app Bạn sẽ thấy hai pod với trạng thái Running.\nKiểm tra service và lấy Load Balancer URL:\nkubectl get service workshop-app-service Sẽ mất một hoặc hai phút để AWS cung cấp load balancer. EXTERNAL-IP sẽ thay đổi từ \u003cpending\u003e thành một DNS name dài.\nTest ứng dụng! Copy DNS name EXTERNAL-IP và dán vào trình duyệt web. Bạn sẽ thấy thông báo: Hello, FCJ-ers!",
    "description": "Tạo Cấu hình EKS Cluster Chúng ta sẽ sử dụng eksctl để build cluster. Thực tiễn tốt nhất là định nghĩa cluster trong một file cấu hình, sau đó bạn có thể commit vào Git repository để kiểm soát phiên bản và tái tạo.\nTrong root directory của dự án, tạo thư mục mới có tên k8s.\nmkdir k8s cd k8s Tạo file mới có tên cluster.yaml\nDán nội dung sau vào cluster.yaml. Đọc các comment để hiểu từng dòng làm gì",
    "tags": [],
    "title": "Cung cấp EKS Cluster và Tự động hóa Deployment",
    "uri": "/vi/provision-eks-cluster-and-ecr-repository/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "Mục tiêu của chúng ta ở đây là làm cho cluster tự bảo vệ. Pipeline mà chúng ta đã xây dựng rất tốt, nhưng nó không ngăn chặn ai đó có quyền truy cập kubectl deploy thủ công một container không an toàn. Bây giờ chúng ta sẽ cài đặt một gatekeeper–một admission controller–để thực thi các quy tắc của chúng ta trên mọi workload cố gắng chạy trên cluster.\nCông cụ của chúng ta cho việc này là Kyverno. Nó mạnh mẽ, native với Kubernetes, và các policy chỉ là YAML đơn giản, làm cho nó hoàn hảo cho dự án của chúng ta.\nCài đặt Kyverno sử dụng Helm Helm là cách tốt nhất để cài đặt và quản lý các ứng dụng phức tạp như Kyverno trên Kubernetes.\nMở terminal, đảm bảo context kubectl của bạn đang trỏ đến workshop-cluster.\nThêm Kyverno Helm repository:\nhelm repo add kyverno https://kyverno.github.io/kyverno/ Cập nhật Helm repository để lấy thông tin chart mới:\nhelm repo update Cài đặt Kyverno vào namespace chuyên dụng riêng. Đây là thực tiễn tốt nhất cho các công cụ cluster-wide.\nhelm install kyverno kyverno/kyverno -n kyverno --create-namespace Xác minh cài đặt. Có thể mất một phút để tất cả pod Kyverno sẵn sàng.\nkubectl get pods -n kyverno Bạn sẽ thấy một số pod, bao gồm admission controller, background controller và cleanup controller, tất cả ở trạng thái Running.\nTạo Policy Bảo mật Đầu tiên Bây giờ đến phần mạnh mẽ. Chúng ta sẽ định nghĩa các quy tắc bảo mật như tài nguyên ClusterPolicy. Đây là các quy tắc cluster-wide.\nTrong thư mục k8s của dự án, tạo file mới có tên policy-disallow-latest-tag.yaml:\n# Trong thư mục k8s touch policy-disallow-latest-tag.yaml Dán policy sau. Đây là thực tiễn tốt nhất cơ bản: nó ngăn chặn deployment mơ hồ và buộc sử dụng tag cụ thể, không thể thay đổi (như Git SHA chúng ta sử dụng trong pipeline).\n# k8s/policy-disallow-latest-tag.yaml apiVersion: kyverno.io/v1 kind: ClusterPolicy metadata: name: disallow-latest-tag spec: # Rule này áp dụng cho tất cả Pod, Deployment, StatefulSet, v.v. validationFailureAction: Enforce background: true rules: - name: require-not-latest-tag match: any: - resources: kinds: - Pod validate: message: \"Sử dụng image tag 'latest' là rủi ro bảo mật và không được phép. Vui lòng sử dụng image tag cụ thể.\" pattern: spec: containers: # Pattern này nói \"trường image của BẤT KỲ container nào KHÔNG ĐƯỢC kết thúc bằng :latest\" - image: \"!*:latest\" Thông tin validationFailureAction: Enforce là chìa khóa. Nó nói với Kyverno chặn bất kỳ API request nào vi phạm quy tắc này. Thay thế, Audit, sẽ chỉ log vi phạm. Chúng ta muốn nghiêm ngặt.\nTạo file policy thứ hai có tên policy-require-non-root.yaml:\n# Trong thư mục k8s touch policy-require-non-root.yaml Dán policy này. Nó thực thi rằng container không thể chạy như root user, điều này giảm đáng kể bán kính nổ nếu container bị tấn công. Điều này biến thực tiễn tốt nhất từ Dockerfile của chúng ta thành quy tắc cluster-wide không thể thương lượng.\n# k8s/policy-require-non-root.yaml apiVersion: kyverno.io/v1 kind: ClusterPolicy metadata: name: require-non-root-user spec: validationFailureAction: Enforce background: true rules: - name: check-for-non-root match: any: - resources: kinds: - Pod exclude: any: # Loại trừ Falco và Starboard namespace - resources: namespaces: - falco - falco-system - starboard - starboard-system - starboard-operator # Loại trừ pod với privileged system label - resources: selector: matchLabels: app.kubernetes.io/name: falco # Loại trừ system namespace thường cần root - resources: namespaces: - kube-system - istio-system - monitoring validate: message: \"Container không được chạy với quyền root. Đặt spec.securityContext.runAsNonRoot thành true ở cấp độ pod hoặc container.\" anyPattern: # Pattern 1: Security context cấp độ Pod với runAsNonRoot: true - spec: securityContext: runAsNonRoot: true # Pattern 2: Tất cả container có runAsNonRoot: true trong security context - spec: containers: - securityContext: runAsNonRoot: true Apply và Test Policy Apply policy vào cluster sử dụng kubectl:\nkubectl apply -f k8s/policy-disallow-latest-tag.yaml kubectl apply -f k8s/policy-require-non-root.yaml Test policy “disallow-latest-tag”. Bây giờ, thử tạo pod thủ công sử dụng tag latest. Điều này mô phỏng những gì developer có thể làm, bỏ qua CI/CD pipeline của bạn.\nkubectl run test-pod --image=nginx:latest Request sẽ bị từ chối! Bạn sẽ nhận được thông báo lỗi trực tiếp từ Kubernetes API server, chứa custom message từ policy của bạn:\nError from server: admission webhook \"validate.kyverno.svc-fail\" denied the request: resource Pod/default/test-pod was blocked due to the following policies disallow-latest-tag: require-not-latest-tag: 'validation error: Sử dụng image tag ''latest'' là rủi ro bảo mật và không được phép. Vui lòng sử dụng image tag cụ thể. rule require-not-latest-tag failed at path /spec/containers/0/image/' Test policy “require-non-root”. Bây giờ thử chạy container mặc định, thường chạy với quyền root.\ncat \u003c\u003cEOF | kubectl apply -f - apiVersion: v1 kind: Pod metadata: name: test-root-pod namespace: default spec: containers: - name: nginx image: nginx:1.21 # Pod này sẽ bị CHẶN bởi policy vì nó không chỉ định runAsNonRoot EOF Điều này cũng sẽ bị từ chối với thông báo rõ ràng giải thích rằng container phải được cấu hình để chạy như non-root.\nDọn dẹp test pod thất bại (chúng sẽ không được tạo, nhưng kubectl run có thể tạo deployment object):\nkubectl delete pod test-root-pod-blocked --ignore-not-found Commit file policy mới vào Git repository của bạn.\ngit add . git commit -m \"feat: Implement Kyverno admission control policies\" git push origin main",
    "description": "Mục tiêu của chúng ta ở đây là làm cho cluster tự bảo vệ. Pipeline mà chúng ta đã xây dựng rất tốt, nhưng nó không ngăn chặn ai đó có quyền truy cập kubectl deploy thủ công một container không an toàn. Bây giờ chúng ta sẽ cài đặt một gatekeeper–một admission controller–để thực thi các quy tắc của chúng ta trên mọi workload cố gắng chạy trên cluster.",
    "tags": [],
    "title": "Cài đặt và Cấu hình Kyverno như Cluster Gatekeeper",
    "uri": "/vi/install-and-configure-kyverno-as-cluster-gatekeeper/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "Chúng ta sẽ tập trung trước tiên vào phần bảo mật runtime. Nhiệm vụ của chúng ta là phát hiện và cảnh báo về hoạt động đáng ngờ trong các container đang chạy theo thời gian thực.\nCông cụ của chúng ta cho việc này là Falco, tiêu chuẩn open-source CNCF cho phát hiện mối đe dọa runtime cloud-native. Nó hoạt động như một camera bảo mật theo dõi system call và cảnh báo bạn khi container làm điều gì đó không nên làm.\nCài đặt Falco sử dụng Helm Giống như với Kyverno, Helm là cách đơn giản nhất để deploy Falco và các thành phần của nó.\nMở terminal và đảm bảo bạn đã kết nối với EKS cluster.\nThêm Falco Security Helm repository:\nhelm repo add falcosecurity https://falcosecurity.github.io/charts Cập nhật Helm repository:\nhelm repo update Cài đặt Falco vào namespace falco riêng. Falco hoạt động bằng cách deploy DaemonSet, có nghĩa là nó sẽ chạy một Falco pod trên mỗi worker node để giám sát tất cả hoạt động trên node đó.\nhelm install --replace falco --namespace falco --create-namespace --set tty=true falcosecurity/falco Xác minh cài đặt. Có thể mất một hoặc hai phút để pod khởi động.\nkubectl get pods -n falco Quan sát Log của Falco Hành vi mặc định của Falco là xuất cảnh báo vào log. Hãy xem chúng để thấy hoạt động bình thường trông như thế nào và chuẩn bị để xem cảnh báo.\nTail log từ tất cả Falco pod. Flag -f sẽ “follow” log, streaming chúng đến terminal theo thời gian thực. kubectl logs -n falco -l app.kubernetes.io/name=falco -f Kích hoạt Cảnh báo Bảo mật Bây giờ chúng ta sẽ mô phỏng pattern tấn công phổ biến: kẻ tấn công có quyền truy cập vào container đang chạy và cố gắng leo thang đặc quyền hoặc cài đặt công cụ độc hại bằng cách spawn shell.\nMở cửa sổ terminal hoặc tab MỚI. Đừng đóng cái đang tail Falco log.\nTìm một trong những application pod đang chạy:\nkubectl get pods -l app=workshop-app Copy tên đầy đủ của một pod (ví dụ: workshop-app-5f4b6c8b9d-abcde).\n“Shell” vào container đang chạy. Lệnh exec này cung cấp cho bạn interactive shell bên trong container.\nkubectl exec -it \u003cyour-app-pod-name\u003e -- /bin/sh Terminal prompt sẽ thay đổi, chỉ ra rằng bạn hiện đang ở bên trong container (ví dụ: $ hoặc #).\nChứng kiến Phát hiện Thời gian Thực Ngay lập tức chuyển lại cửa sổ terminal đầu tiên (cái có Falco log).\nTrong vài giây sau khi thực thi lệnh exec, bạn sẽ thấy log entry mới định dạng JSON từ Falco. Nó sẽ trông tương tự như thế này:\n08:29:42.827362021: Notice A shell was spawned in a container with an attached terminal | evt_type=execve user=appuser user_uid=1001 user_loginuid=-1 process=sh proc_exepath=/usr/bin/dash parent=containerd-shim command=sh terminal=34816 exe_flags=EXE_LOWER_LAYER container_id=c2d197da82de container_name=workshop-app container_image_repository=593793056386.dkr.ecr.us-east-2.amazonaws.com/workshop-app container_image_tag=9fb43f1fb58cae94f85f5a8ba31c105b43b26068 k8s_pod_name=workshop-app-77d986f5b6-76tvd k8s_ns_name=default Thông tin “Notice”: Đây là mức độ nghiêm trọng mặc định cho rule này.\nBây giờ, hãy kích hoạt cảnh báo nghiêm trọng hơn.\nQuay lại terminal nơi bạn đang ở bên trong container.\nThoát container.\nexit Tạm thời xóa Kyverno require-non-root-user policy.\nkubectl delete clusterpolicy require-non-root-user Hãy tạo nginx deployment:\nkubectl create deployment nginx --image=nginx Thực thi lệnh sẽ kích hoạt rule:\nkubectl exec -it $(kubectl get pods --selector=app=nginx -o name) -- cat /etc/shadow Chuyển lại Falco log. Bạn sẽ thấy cảnh báo khác, nghiêm trọng hơn:\nBạn sẽ thấy log cho tất cả Falco pod được deploy trên hệ thống. Falco pod tương ứng với node mà nginx deployment đang chạy đã phát hiện sự kiện, và bạn sẽ có thể đọc dòng như:\n08:58:14.478370676: Warning Sensitive file opened for reading by non-trusted program | file=/etc/shadow gparent=systemd ggparent=\u003cNA\u003e gggparent=\u003cNA\u003e evt_type=openat user=root user_uid=0 user_loginuid=-1 process=cat proc_exepath=/usr/bin/cat parent=containerd-shim command=cat /etc/shadow terminal=34816 container_id=4c908449279e container_name=nginx container_image_repository=docker.io/library/nginx container_image_tag=latest k8s_pod_name=nginx-5869d7778c-kfdjf k8s_ns_name=default Dọn dẹp và roll back: Bạn có thể dừng tail Falco log bằng cách nhấn Ctrl+C trong cửa sổ đó. Bạn cũng nên re-apply Kyverno require-non-root-user policy.\nkubectl delete deployment nginx kubectl apply -f k8s/policy-require-non-root.yaml",
    "description": "Chúng ta sẽ tập trung trước tiên vào phần bảo mật runtime. Nhiệm vụ của chúng ta là phát hiện và cảnh báo về hoạt động đáng ngờ trong các container đang chạy theo thời gian thực.\nCông cụ của chúng ta cho việc này là Falco, tiêu chuẩn open-source CNCF cho phát hiện mối đe dọa runtime cloud-native. Nó hoạt động như một camera bảo mật theo dõi system call và cảnh báo bạn khi container làm điều gì đó không nên làm.",
    "tags": [],
    "title": "Cài đặt và Test Falco cho Phát hiện Mối đe dọa Runtime",
    "uri": "/vi/install-and-test-falco-for-runtime-threat-detection/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "Tổng quan Sau khi hoàn thành workshop, hoặc nếu bạn gặp bất kỳ lỗi deployment nào, bạn nên dọn dẹp tài nguyên AWS để tránh phí không cần thiết. Hướng dẫn này cung cấp hướng dẫn từng bước để xóa đúng cách tất cả tài nguyên đã deploy.\nQuy trình Dọn dẹp Thực hiện các bước này theo thứ tự được chỉ định để đảm bảo tất cả tài nguyên được xóa đúng cách:\nBước 1: Xóa EKS Cluster Trong thư mục dự án secure-container-pipeline, chạy lệnh eksctl sau:\neksctl delete cluster -f k8s/cluster.yaml --wait --disable-nodegroup-eviction --force --parallel 4 Bước 2: Xóa ECR Repository Chạy lệnh AWS CLI trong terminal:\naws ecr delete-repository \\ --repository-name workshop-app \\ --region us-east-2 # Sử dụng cùng region với cluster của bạn Bước 3: Xóa IAM Role và Identity provider Trong AWS Console, đi đến IAM → Roles. Chọn role WorkshopGitHubActionsRole. Click Delete. Nhập tên role để xác nhận xóa. Click Delete. Đi đến IAM → Roles Chọn provider token.actions.githubusercontent.com. Click Delete. Gõ confirm để xác nhận xóa. Click Delete.",
    "description": "Tổng quan Sau khi hoàn thành workshop, hoặc nếu bạn gặp bất kỳ lỗi deployment nào, bạn nên dọn dẹp tài nguyên AWS để tránh phí không cần thiết. Hướng dẫn này cung cấp hướng dẫn từng bước để xóa đúng cách tất cả tài nguyên đã deploy.\nQuy trình Dọn dẹp Thực hiện các bước này theo thứ tự được chỉ định để đảm bảo tất cả tài nguyên được xóa đúng cách:",
    "tags": [],
    "title": "Dọn dẹp tài nguyên",
    "uri": "/vi/clean-up-resources/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Thể loại",
    "uri": "/vi/categories/index.html"
  },
  {
    "breadcrumb": "Bảo mật Container Registry với Quét Lỗ hổng và Thực thi Chính sách",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Thẻ",
    "uri": "/vi/tags/index.html"
  }
]
